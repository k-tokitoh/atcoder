- 木はグラフの特殊形であるという理解ができた
  - [任意の node が他のただひとつの node に向けた edge をもつのが木](https://hiroakiuno.hatenablog.com/entry/20090225/p1)
  - この問題でいうと
    - N-1 の edge があるので、毎回木に対してあらたな node を追加していかないと「全部つながっている」という条件をみたさない
    - N-1 回新たな node を追加していくということは、閉路は生じていないということ
  - なのでグラフでつかえるツール（DFS, BFS など）は木に対してもつかえる
- 木の直径は任意の node から一番とおい node を探し、その node から一番とおり node を探すというの、理解した
- DFS / BFS
  - 実装
    - DFS
      - 再帰 or FILO キュー
    - BFS
      - FIFO キュー
  - メリデメ
    - BFS のメリット
      - 最短経路をみつけるだけなら全部調べなくていい
    - DFS のメリット
      - 探索途中のノードを保持しておく必要がないためメモリ消費量が少ない
- 重みなしグラフは DFS, BFS, 重みつきグラフはダイクストラ法やワーシャルフロイド法
- 隣接行列だと大きくなりすぎそうだけど、単なる配列だと一方向にしかいけない気がしたので隣接リストがよさそう、と発想できた
- c++に union type ってないの、とおもったら共用体というのがそれらしい
  - 競プロではつかう機会なさそうかな
