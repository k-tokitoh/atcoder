# abc214/c

- ダイクストラ法の練習
- 一般には未確定のノードのうち最小の値をもつノードから順に確定させていくが、この問題ではグラフが特殊な形をしているため
  - グラフの表現に隣接リスト/隣接行列を用いる必要がなく vector で十分であり
  - 確定させる順序も最初に最小の値をもつ要素を特定したあとは順次 vector の次の要素が定まる
- vector の min/max は以下

```cpp
#include <algorithm>

vector< int >v;

// index は以下で求められる
size_t i = distance(T.begin(), min_element(T.begin(), T.end()));

// 値 は以下で求められる
v[i];
```
# abc208/d

- ワーシャルフロイド法
- [この解説](https://blog.hamayanhamayan.com/entry/2021/07/05/013220)がわかりやすかった
- 隣接行列、自身に対するコストを 0 に初期化するのを忘れずに
# abc035/d

ダイクストラの計算量(n+m)log n を理解したい
逆向きで帰るコストを一発で調べる！なるほどにぇ〜〜
# abc141/d

- はじめての優先度つきキュー
- この問題の計算量
  - 配列で都度 sort して取り出そうとすると、マージソートとかでも O(N\*log N)なので全体としては O(M\*N\*log N)で TLE になる
  - 優先度つきキューなら最初に push していくのが N\*log N, 順次取り出していくのが M\*log N なので収まる
- 構造は[こちらで](https://qiita.com/birdwatcher/items/9e6dac869dea023bf53c#priority_queue-%E5%84%AA%E5%85%88%E5%BA%A6%E4%BB%98%E3%81%8D%E3%82%AD%E3%83%A5%E3%83%BC)
  - pop/push が O(log N), top が O(1)であることも理解した
- 使い方は以下

```cpp
#include <queue>

priority_queue< long long > q;
q.push(1);
q.push(3);
q.push(2);
q.top();  // 3が返る
q.pop();  // voidが返る、中身が1,2になる
```
# typical90/024

- この問題の焦点は偶数 or 奇数。これをパリティという
- 絶対値の取得は以下
  - int は`#include <cstdlib>`で`std:abs()`
  - float は`#include <cmath>`で`std:fabs()`
# typical90/012

- ひとまとまりにつながった union を find するから二次元配列の union find なのではと発想できた
- 4 件 TLE にしたので経路圧縮してみたらとおった
- 型エイリアスは以下のように記述できる

```cpp
using P = pair< int, int >;
```
# typical90/079

- やったぜ一発 AC
- 解説キーワード「操作順序によらない」だけチラ見した
  - 「左上からひとつずつ揃えていって辻褄が合わせられない箇所があるかどうかで判断すればよい、その操作が最小回数である」という気がして、ちゃんと証明できる自信はないけど実装してみたらとおった
# typical90/046

- 自力 AC
- mod にして情報を圧縮してしまえば、たかだか 46\*\*3 で収まると気づけた
# typical90/048

- 自力一発 AC
- 1 分の使い方を効率良い方から順番に K だけ実行する、と発想できた
# typical90/084

- なんかまえやったことあったな、と尺取法を思い出した
  - 尺取法のアイデアは、「この小さな区間で x であることがわかればその外側は調べないでいい」ことを利用するのがポイントっぽい
  - しかし計算量が 10\*\*6\*\*2 とかになってしまう
- 余事象に注目し、かつ、連続する箇所を圧縮する
- c は struct だけ、c++には class もある
  - 実質的にはそんなに違わない、class はカプセル化の思想に基づいてデフォルトのアクセシビリティが private
- vector で要素数は`v.size()`, 最初の要素は`v.front()`, 最後の要素は`v.back()`
# typical90/013

- 双方向ならば、i から N までの最小コストは N から i までの最小コストに等しいのか
- ダイクストラ法、毎回なめて最小のノードみつけるのだと O(n^2), 優先度つきキューだと O((V+E)log V)
- 隣接行列はメモリ消費量が node の数 v^2 に比例するが、隣接リストは edge の数 e に比例するのでメモリ消費量が小さい、pair にすれば重みも保持できる
  - この問題だと隣接リストにする必要がありそう
- `priority_queue<pair<xx, xx>>`とするとひとつめの要素でソートされる
- 実際に扱うあらゆるデータより大きい値は以下で

```cpp
#include <climits>

LLONG_MAX;
```
# typical90/014

- 部分の最適化を全体に適用することで全体としても最適化される、ってのが貪欲法らしい
- 交差を取り除くと不便さの合計は同じか減少するの、直感的にはすぐわかったけど、いくつか場合分けして確かめてみた
- ソートは以下

```cpp
#include <vector>
#include <algorithm>

vector< int > A;
sort(A.begin(), A.end());
```
# typical90/022

- 最大公約数はユークリッドの互除法
  - 互いに除算(互除)し、値を剰余で更新していく
  - 0 になった直前の値が最大公約数
- `gcd(a, b, c)` は `gcd(a, gcd(b, c))`に等しい
- int だと overflow するときは long or long long
# typical90/082

- 「n 桁の数をまとめて、等差数列の和で計算する」というところは自力で発想できた

### 逆元

- [mod の除算だけはそのままできず、逆元をかける必要がある](https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-%E5%89%B2%E3%82%8A%E7%AE%97-a--b)
- 逆元の求め方には以下がある

  - ユークリッドの互除法
    - 以下を理解した
      - [最小公倍数を求めるのを拡張した手順で一次不定方程式が解けること](https://www.youtube.com/watch?v=2t8UepAuWcM)
      - [$a$と$mod$が互いに素 <=> $ax+mod*y=1$が解をもつ](https://manabitimes.jp/math/674) => $mod$ を法とする $a$ の逆元が存在する
  - フェルマーの小定理
    - 以下を理解した
      - [$a^{p-1}\equiv a \mod p$の 2 つの証明](https://manabitimes.jp/math/680)
    - 最小 2 乗法により$a^{p-2}$の剰余、すなわち p を法とする a の逆元を求めるアルゴリズムを実装した

### unsigned long long

$10^19$は long long では扱えないことに注意する。

```
>>> 10**19 < 2**63
False
>>> 10**19 < 2**64
True
```
# typical90/076

- やったぜ自力一発 AC
- 尺取法を発想できたのと、列をクローンしてくっつけたら index の細かい配慮が不要そう、と気づけた
# typical90/078

- やったぜ一発 AC
- 最初 2 次元配列にグラフの状態を記録することを考えたけど、最後操作するときに 10\*\*10 必要になる気がして、
- 各ノードに「自分より小さいノードと繋がっているエッジの数」を記録していくことを思いつけた
- より一般に、グラフの状態の表現方法として隣接行列と隣接リストがあって、今回は後者が適切だったといえる
# typical90/038

- ふつうに式変形すればわかる話なのに気づけなかった。。
- pow が double を返しちゃうけど long long で扱いたい、その場合は以下でいいみたい

```cpp
long long p = pow(10, 18);
```
# typical90/007

### 方針

- [atcoder では 10**8 まではいける]
- `1 <= N <= 3*10**5`, `1 <= Q <= 3*10**5`なので、単純にループすると 10\*\*10 とかになってアウト
- A を sort して二分探索してあげれば`O(n * log n)`で収まりそう

### 実装

```cpp
#include <vector>
#include <algorithm>

// sortは以下
vector<int> V{4,2,3,5,1};
sort(V.begin(), V.end())

// 二分探索は以下。
vector< int >::iterator pos = lower_bound(V.begin(), V.end(), 3);
int index = distance(A.begin(), pos);
```

最小値は以下。

```cpp
#include <algorithm>

min(1,2)
```
# typical90/052

- やったぜ自力一発 AC
- 「10\*\*9 +7 で割った余り」みたいなのって、全部計算してから最後に割るではむり、ということ
  - ちゃんと都度計算していくことを発想できた
- 漸化的に数えていくとしたら「サイコロ n 個がわかってればサイコロ n+1 個のときがわかる」しかないよなあと思い、最初わからなかったけど 3 面サイコロの場合を試しに考えてみたら漸化式がみえた
# typical90/055

- 組み合わせ、100C5 ならたかだか 10\*\*8 とおりなのでできる
- 回答みたら一部再帰でやってるのもあったけど、つよいひとも 5 重ループでやっているみたいだった
- int は 32bit なので 2\*\*32, つまり 10\*\*10 くらいまで、long long は 64bit なので 10\*\*20 くらいまで計算できる
  - 今回は都度剰余をとれば扱う数字は 10\*\*9\*\*2 に収まるので long long で扱いきれる
# typical90/064

- 階差というキーワードだけみて自力 AC
- 都度絶対値を書き換えていくと 10\*\*5 \* 10\*\*5 で LTE になりそう、とはまず思った
- バコンと上がるなら、l-r で挟まれた部分は不便さに変化がなく、境界だけ考えればいいので地殻変動 1 回あたりの処理が定数時間に収まることに気づけた
- vector の合計などの折りたたみ演算は以下でできる

```cpp
#include <numeric>
#include <vector>

vector< int >v = {1,2,3};
accumulate(v.begin(), v.end(), 0);
```
# typical90/008

- やったね自力一発 AC
- 「$10^9+7$でわった余り」だから漸化的に求める必要がありそうだな、そのためには`a`, `at`, `atc`, ... `atcoder`が含まれる数をメモできればよさそう、と発想できた
# typical90/001

- N, L, K いずれに関してもひとつ前の結果から漸化的に求めることはできなさそう、というところまで考えた
- 答えで二分探索
- 探索の終了を知るには、left/right という形で範囲をもっておき、その範囲がただ一つの要素を指示するまで狭めていけばいい
  - 隣接する left: true, right: false だと、mid が left になって true を返すので left に mid が代入して、ずっと繰り返す
  - なので left と right の差が 1 になったとき終了すればよく、left が求める最大値
  - なので left が最終的に最大の値をとるためには、right は最大の値+1 である必要があることに注意する
# typical90/042

# typical90/020

- 桁あふれを回避するって話かと思ったけど、あふれないね
  - `17**13 < 2**63 - 1 # True`
- `pow`も double なので、for で累乗してあげる
# typical90/027

# typical90/018

- ふつうに数学 & 小数の扱い方の問題だった
- 演算するときはもう一方の数も整数なら long long, 小数なら long double にしときゃ間違いない
  - リテラルなら`9L`, `9.9L`のように書く
- 桁数を指定するのは基本 printf でやるのがよさそう
  - int は`%d`, long long は`%lld`, float は`%f`, double は`%lf`, long double は`%Ld`
# typical90/016

素直に考えれば全探索でも 10 \*\*4 \*\*2 とおりなので計算可能となる。
# typical90/075

- 自力 AC
- 素因数分解をして、素因数の数と$2^n$を比べればいいことは発想できた
- 素因数分解も手でやる手順を素直にコードにしたらできた
  - $1$から順に$\sqrt{n}$を超えるまで順次除算を試していく、エラトステネスの篩的な方法
# typical90/044

- やったね自力 AC
- 10\*\*5 \* 10\*\*5 だと計算間に合わないので、シフト操作に O(n)かかっちゃだめ、と気づけた
- deque をつかうことを発想できた
- case で変数宣言するときは`{}`で囲む必要あり
# typical90/043

# typical90/028

- 行列で座標空間を表現することは発想できたが、1 枚重ねるごとに行列を更新すると$10^{5+3+3}$で TLE だなとおもった
- 端点の情報だけとっておき、塗りつぶす箇所についてはあとで全部まとめて、というのを発想できたかった
  - 端点ていうかあれだな、差分だ。存在する紙の枚数の変化
- 累積和って累積をメモって引いて区間の和を求める工夫だと思ってたけど、累積するための情報だけとっといてあとでまとめて累積する、みたいな工夫もできるんだ
- 累積和を二次元に拡張したのをいもす法というらしい
# typical90/010

# 累積和

- 区間の総和 => 累積和と発想する
- 開始地点からそのまでの累積和を配列として保持しておけば、終点 - 始点で区間の和を直ちに求めることができる

# その他

- c++も三項演算子つかえる
# typical90/026

- 木構造ならグラフを配列で表現できるはずだが、向きがわからずに edge が与えられるので隣接リストで保持する
- 2 つのグループにわけることができて、しかし"少なくとも一方が"N/2 以上になる、ということに注意できなかった
# typical90/003

- 木はグラフの特殊形であるという理解ができた
  - [任意の node が他のただひとつの node に向けた edge をもつのが木](https://hiroakiuno.hatenablog.com/entry/20090225/p1)
  - この問題でいうと
    - N-1 の edge があるので、毎回木に対してあらたな node を追加していかないと「全部つながっている」という条件をみたさない
    - N-1 回新たな node を追加していくということは、閉路は生じていないということ
  - なのでグラフでつかえるツール（DFS, BFS など）は木に対してもつかえる
- 木の直径は任意の node から一番とおい node を探し、その node から一番とおり node を探すというの、理解した
- DFS / BFS
  - 実装
    - DFS
      - 再帰 or FILO キュー
    - BFS
      - FIFO キュー
  - メリデメ
    - BFS のメリット
      - 最短経路をみつけるだけなら全部調べなくていい
    - DFS のメリット
      - 探索途中のノードを保持しておく必要がないためメモリ消費量が少ない
- 重みなしグラフは DFS, BFS, 重みつきグラフはダイクストラ法やワーシャルフロイド法
- 隣接行列だと大きくなりすぎそうだけど、単なる配列だと一方向にしかいけない気がしたので隣接リストがよさそう、と発想できた
- c++に union type ってないの、とおもったら共用体というのがそれらしい
  - 競プロではつかう機会なさそうかな
# typical90/004

# vector

```cpp
#include<vector>
using namespace std;

// 初期化
vector<int> a;

// 要素数を指定して初期化
vector<int> a(10);

// 全要素共通の値を指定して初期化
vector<int> a(10, 777);

// 全要素共通の値を指定して初期化
vector<int> a{2,4,6};
```
# typical90/032

- やったぜ自力 AC
  - 全探索でいけそう、とみおとしをたてることができた
    - `10*9*8*7*6*5*4*3*2*1 * 10 < 10**9 # True`
- 集合は以下で扱える

```cpp
#include <set>

set< int >s = {1,2,3};
```

- 順列は以下で

```cpp
#include <algorithm>
#include <vector>

vector< int >v = {1,2,3};

do {
  // whatever
} while (next_permutation(v.begin(), v.end()));
```
# typical90/061

- 先頭要素の追加、vector だと O(n)になっちゃうから他のデータ構造が必要そう、ということは気づけた
- 先頭要素追加が O(1)でできる std::list をみつけてつかってみたが、ランダムアクセスが O(n)なので TLE
  - なんだか教育的な間違い方だ
- std::deque なら先頭/末尾要素追加もランダムアクセスも O(1)でできるとのこと
  - 配列の部分を管理するっていう発想なのか
  - ランダムアクセスも[]oeperator でできて便利。(std::list は iterator を for で回す必要あり)
- deck だから deque, っていう言葉遊びなんだろうな
# typical90/050

- DP というキーワードだけチラ見して自力一発 AC
  - 自分で発想できたかった。。。
- くばる DP でシンプルにいけるとみとおせた
# typical90/034

- 数値の出現回数をメモして、しゃくとり法つかえばいいんじゃないと思って、なんとか自力一発 AC！
# typical90/033

- コーナーケース気づけなかった。。問題をよく読むべし..!
# typical90/002

# 方針

- なんかうまく調べる方法ありそうだと思って全探索を発想できなかった...
- 2\*\*20 < 10\*\*7 だから全探索でいけるのね

# 実装

- 2\*\*n を全探索するのは bit を用いる
- `for (int i = 0; i < (1 << n); i++)`で 2\*\*n とおりのループを回すことができる、なるほどなー
- それぞれの場合で j の位置の bit の 0/1 を判定するには論理和をつかって`i & (1 << j)`

# その他

- `i++`は i を返し`++i`は i+1 を返すが、どちらでもインクリメントできる
- printf, ビット形式での出力はできないらしい
- ビット形式で出力するには以下

```cpp
#include <bitset>

int i;
bitset<width> b(i);
cout << b << endl;
```
# typical90/069

- 繰り返し 2 乗法
  - $a^b$ を mod で割った余りは、$b$ が $10^{18}$ のように巨大であっても短時間で求めることができる
  - シンプルに乗じていくと $O(b)$の計算が必要
  - しかしたとえば$5^{13}$は$5^{8}*5^{4}*5^{1}$のように表せることを利用すると、
  - 右辺の各項の mod で割った余りを求めて乗じていくのはたかだか $\log N$の計算で実行できる
# typical90/067

### 変換

#### int to char

```cpp
char c = n + '0';
```

#### char to int

```cpp
int n = c - '0';
```

#### string to int

```cpp
#include <string>

int n = stoi(str);
```

#### int to string

```cpp
#include <string>

string str = to_string(n);
```

### べき乗

```cpp
#include <cmath>

pow(10, 3);
```

### 文字列の置換

```cpp
#include <regex>

regex_replace(str, regex("foo"), "bar");
```

### long long の整数リテラル

```cpp
1LL;
```

### クォーテーション

```cpp
char c = 'x'
string s = "x"
```

### pow

- double を返すので、long long と扱える値の範囲が異なるみたい？
- n 進法展開の場合は pow ではなく基数のべき乗や商を都度再代入していくのがよさそう。
# atc001/b

- union find の考え方は[こちらのスライド](https://atcoder.jp/contests/atc001/tasks/unionfind_a)で理解した
- 論理的には木構造、実装としては配列、というのが初めてわかった
- コンストラクタでメンバのオブジェクトを必要とするときは、引数の後ろに`: member_1(construct_args_1), member_2(construct_args_2)`と記述する
  - これらひとつひとつをメンバ初期化子、全体をコンストラクタ初期化子と呼ぶ
  - 今回の例では、parents というメンバに関して、`vector<long long>`のコンストラクタに引数`n`を渡したいので、`: parents(n)`と記述する
